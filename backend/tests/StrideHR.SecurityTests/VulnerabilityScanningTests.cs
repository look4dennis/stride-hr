using FluentAssertions;
using Microsoft.AspNetCore.Mvc.Testing;
using StrideHR.SecurityTests.Infrastructure;

namespace StrideHR.SecurityTests;

public class VulnerabilityScanningTests : SecurityTestBase
{
    private readonly VulnerabilityScanner _scanner;

    public VulnerabilityScanningTests(WebApplicationFactory<Program> factory) : base(factory)
    {
        _scanner = new VulnerabilityScanner(_client);
    }

    [Theory]
    [InlineData("/api/employees")]
    [InlineData("/api/auth/login")]
    [InlineData("/api/payroll")]
    [InlineData("/api/attendance")]
    [InlineData("/api/leave")]
    [InlineData("/api/performance")]
    [InlineData("/api/projects")]
    [InlineData("/api/reports")]
    public async Task ScanEndpoint_ShouldNotHaveCriticalVulnerabilities(string endpoint)
    {
        // Act
        var scanResult = await _scanner.ScanForVulnerabilitiesAsync(endpoint);

        // Assert
        var criticalVulnerabilities = scanResult.Vulnerabilities
            .Where(v => v.Severity == VulnerabilitySeverity.Critical)
            .ToList();

        criticalVulnerabilities.Should().BeEmpty(
            $"Critical vulnerabilities found in {endpoint}: {string.Join(", ", criticalVulnerabilities.Select(v => v.Description))}");
    }

    [Theory]
    [InlineData("/api/employees")]
    [InlineData("/api/payroll")]
    [InlineData("/api/attendance")]
    [InlineData("/api/leave")]
    [InlineData("/api/performance")]
    [InlineData("/api/projects")]
    [InlineData("/api/reports")]
    public async Task ScanEndpoint_ShouldNotHaveSqlInjectionVulnerabilities(string endpoint)
    {
        // Act
        var scanResult = await _scanner.ScanForVulnerabilitiesAsync(endpoint);

        // Assert
        var sqlInjectionVulnerabilities = scanResult.Vulnerabilities
            .Where(v => v.Type == VulnerabilityType.SqlInjection)
            .ToList();

        sqlInjectionVulnerabilities.Should().BeEmpty(
            $"SQL injection vulnerabilities found in {endpoint}: {string.Join(", ", sqlInjectionVulnerabilities.Select(v => $"{v.Description} - Payload: {v.Payload}"))}");
    }

    [Theory]
    [InlineData("/api/employees")]
    [InlineData("/api/payroll")]
    [InlineData("/api/attendance")]
    [InlineData("/api/leave")]
    [InlineData("/api/performance")]
    [InlineData("/api/projects")]
    [InlineData("/api/reports")]
    public async Task ScanEndpoint_ShouldNotHaveXssVulnerabilities(string endpoint)
    {
        // Act
        var scanResult = await _scanner.ScanForVulnerabilitiesAsync(endpoint);

        // Assert
        var xssVulnerabilities = scanResult.Vulnerabilities
            .Where(v => v.Type == VulnerabilityType.CrossSiteScripting)
            .ToList();

        xssVulnerabilities.Should().BeEmpty(
            $"XSS vulnerabilities found in {endpoint}: {string.Join(", ", xssVulnerabilities.Select(v => $"{v.Description} - Payload: {v.Payload}"))}");
    }

    [Theory]
    [InlineData("/api/employees")]
    [InlineData("/api/payroll")]
    [InlineData("/api/attendance")]
    [InlineData("/api/leave")]
    [InlineData("/api/performance")]
    [InlineData("/api/projects")]
    [InlineData("/api/reports")]
    public async Task ScanEndpoint_ShouldHaveRequiredSecurityHeaders(string endpoint)
    {
        // Act
        var scanResult = await _scanner.ScanForVulnerabilitiesAsync(endpoint);

        // Assert
        var missingSecurityHeaders = scanResult.Vulnerabilities
            .Where(v => v.Type == VulnerabilityType.MissingSecurityHeaders && 
                       v.Severity >= VulnerabilitySeverity.Medium)
            .ToList();

        // Allow some flexibility for development environment
        var allowedMissingHeaders = new[] { "Strict-Transport-Security" }; // HSTS not required in dev
        var criticalMissingHeaders = missingSecurityHeaders
            .Where(v => !allowedMissingHeaders.Any(allowed => v.Description.Contains(allowed)))
            .ToList();

        criticalMissingHeaders.Should().BeEmpty(
            $"Critical security headers missing in {endpoint}: {string.Join(", ", criticalMissingHeaders.Select(v => v.Description))}");
    }

    [Theory]
    [InlineData("/api/employees")]
    [InlineData("/api/payroll")]
    [InlineData("/api/attendance")]
    [InlineData("/api/leave")]
    [InlineData("/api/performance")]
    [InlineData("/api/projects")]
    [InlineData("/api/reports")]
    public async Task ScanEndpoint_ShouldNotDiscloseSensitiveInformation(string endpoint)
    {
        // Act
        var scanResult = await _scanner.ScanForVulnerabilitiesAsync(endpoint);

        // Assert
        var informationDisclosureVulnerabilities = scanResult.Vulnerabilities
            .Where(v => v.Type == VulnerabilityType.InformationDisclosure && 
                       v.Severity >= VulnerabilitySeverity.Medium)
            .ToList();

        informationDisclosureVulnerabilities.Should().BeEmpty(
            $"Information disclosure vulnerabilities found in {endpoint}: {string.Join(", ", informationDisclosureVulnerabilities.Select(v => v.Description))}");
    }

    [Fact]
    public async Task GenerateSecurityReport_ShouldCreateComprehensiveReport()
    {
        // Arrange
        var endpoints = new[]
        {
            "/api/employees",
            "/api/auth/login",
            "/api/payroll",
            "/api/attendance",
            "/api/leave",
            "/api/performance",
            "/api/projects",
            "/api/reports"
        };

        var allResults = new List<SecurityScanResult>();

        // Act
        foreach (var endpoint in endpoints)
        {
            var result = await _scanner.ScanForVulnerabilitiesAsync(endpoint);
            allResults.Add(result);
        }

        // Assert & Report
        var totalVulnerabilities = allResults.SelectMany(r => r.Vulnerabilities).ToList();
        var criticalCount = totalVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
        var highCount = totalVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
        var mediumCount = totalVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
        var lowCount = totalVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low);

        // Generate report
        var report = $@"
=== SECURITY SCAN REPORT ===
Scan Date: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC
Endpoints Scanned: {endpoints.Length}

VULNERABILITY SUMMARY:
- Critical: {criticalCount}
- High: {highCount}
- Medium: {mediumCount}
- Low: {lowCount}
- Total: {totalVulnerabilities.Count}

DETAILED FINDINGS:
{string.Join("\n", allResults.SelectMany(r => r.Vulnerabilities.Select(v => 
    $"[{v.Severity}] {r.Endpoint}: {v.Description} - {v.Evidence}")))}

=== END REPORT ===
";

        // Output report for visibility
        Console.WriteLine(report);

        // Assert no critical vulnerabilities
        criticalCount.Should().Be(0, "No critical vulnerabilities should be present");
        
        // Assert minimal high-severity vulnerabilities
        highCount.Should().BeLessOrEqualTo(2, "High-severity vulnerabilities should be minimal");
    }
}