using AngleSharp;
using AngleSharp.Html.Dom;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;

namespace StrideHR.SecurityTests.Infrastructure;

public class VulnerabilityScanner
{
    private readonly HttpClient _httpClient;
    private readonly List<SecurityVulnerability> _vulnerabilities;

    public VulnerabilityScanner(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _vulnerabilities = new List<SecurityVulnerability>();
    }

    public async Task<SecurityScanResult> ScanForVulnerabilitiesAsync(string endpoint)
    {
        _vulnerabilities.Clear();

        await ScanForSqlInjectionAsync(endpoint);
        await ScanForXssVulnerabilitiesAsync(endpoint);
        await ScanForCsrfVulnerabilitiesAsync(endpoint);
        await ScanForSecurityHeadersAsync(endpoint);
        await ScanForInformationDisclosureAsync(endpoint);

        return new SecurityScanResult
        {
            Endpoint = endpoint,
            Vulnerabilities = _vulnerabilities.ToList(),
            ScanDate = DateTime.UtcNow
        };
    }

    private async Task ScanForSqlInjectionAsync(string endpoint)
    {
        var sqlInjectionPayloads = new[]
        {
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' OR '1'='1' --",
            "admin'--",
            "' OR 1=1#",
            "') OR ('1'='1",
            "1; SELECT * FROM users",
            "' OR 'a'='a",
            "1' UNION SELECT null,username,password FROM users--"
        };

        foreach (var payload in sqlInjectionPayloads)
        {
            try
            {
                // Test GET parameters
                var getResponse = await _httpClient.GetAsync($"{endpoint}?id={Uri.EscapeDataString(payload)}");
                await AnalyzeResponseForSqlInjection(getResponse, payload, "GET parameter");

                // Test POST data
                var postContent = new StringContent($"{{\"id\":\"{payload}\"}}", Encoding.UTF8, "application/json");
                var postResponse = await _httpClient.PostAsync(endpoint, postContent);
                await AnalyzeResponseForSqlInjection(postResponse, payload, "POST data");
            }
            catch (Exception ex)
            {
                // Log but don't fail the test for network issues
                Console.WriteLine($"Error testing SQL injection payload '{payload}': {ex.Message}");
            }
        }
    }

    private async Task AnalyzeResponseForSqlInjection(HttpResponse response, string payload, string attackVector)
    {
        var content = await response.Content.ReadAsStringAsync();
        var statusCode = (int)response.StatusCode;

        // Check for SQL error messages
        var sqlErrorPatterns = new[]
        {
            @"SQL syntax.*MySQL",
            @"Warning.*mysql_.*",
            @"valid MySQL result",
            @"MySqlClient\.MySqlException",
            @"Microsoft OLE DB Provider for ODBC Drivers",
            @"Microsoft JET Database Engine",
            @"ORA-\d{5}",
            @"PostgreSQL.*ERROR",
            @"Warning.*pg_.*",
            @"valid PostgreSQL result",
            @"Npgsql\.",
            @"System\.Data\.SqlClient\.SqlException",
            @"Unclosed quotation mark after the character string"
        };

        foreach (var pattern in sqlErrorPatterns)
        {
            if (Regex.IsMatch(content, pattern, RegexOptions.IgnoreCase))
            {
                _vulnerabilities.Add(new SecurityVulnerability
                {
                    Type = VulnerabilityType.SqlInjection,
                    Severity = VulnerabilitySeverity.High,
                    Description = $"SQL injection vulnerability detected via {attackVector}",
                    Payload = payload,
                    Evidence = $"SQL error pattern found: {pattern}",
                    StatusCode = statusCode
                });
                break;
            }
        }

        // Check for unusual response times (potential blind SQL injection)
        if (response.Headers.Contains("X-Response-Time"))
        {
            var responseTime = response.Headers.GetValues("X-Response-Time").FirstOrDefault();
            if (double.TryParse(responseTime, out var time) && time > 5000) // 5 seconds
            {
                _vulnerabilities.Add(new SecurityVulnerability
                {
                    Type = VulnerabilityType.SqlInjection,
                    Severity = VulnerabilitySeverity.Medium,
                    Description = $"Potential blind SQL injection detected via {attackVector}",
                    Payload = payload,
                    Evidence = $"Unusual response time: {time}ms",
                    StatusCode = statusCode
                });
            }
        }
    }

    private async Task ScanForXssVulnerabilitiesAsync(string endpoint)
    {
        var xssPayloads = new[]
        {
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>"
        };

        foreach (var payload in xssPayloads)
        {
            try
            {
                // Test GET parameters
                var getResponse = await _httpClient.GetAsync($"{endpoint}?search={Uri.EscapeDataString(payload)}");
                await AnalyzeResponseForXss(getResponse, payload, "GET parameter");

                // Test POST data
                var postContent = new StringContent($"{{\"search\":\"{payload}\"}}", Encoding.UTF8, "application/json");
                var postResponse = await _httpClient.PostAsync(endpoint, postContent);
                await AnalyzeResponseForXss(postResponse, payload, "POST data");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error testing XSS payload '{payload}': {ex.Message}");
            }
        }
    }

    private async Task AnalyzeResponseForXss(HttpResponse response, string payload, string attackVector)
    {
        var content = await response.Content.ReadAsStringAsync();
        var statusCode = (int)response.StatusCode;

        // Check if payload is reflected in response without proper encoding
        if (content.Contains(payload))
        {
            _vulnerabilities.Add(new SecurityVulnerability
            {
                Type = VulnerabilityType.CrossSiteScripting,
                Severity = VulnerabilitySeverity.High,
                Description = $"XSS vulnerability detected via {attackVector}",
                Payload = payload,
                Evidence = "Payload reflected in response without proper encoding",
                StatusCode = statusCode
            });
        }

        // Check for HTML content type without proper CSP headers
        var contentType = response.Content.Headers.ContentType?.MediaType;
        if (contentType?.StartsWith("text/html") == true)
        {
            if (!response.Headers.Contains("Content-Security-Policy"))
            {
                _vulnerabilities.Add(new SecurityVulnerability
                {
                    Type = VulnerabilityType.MissingSecurityHeaders,
                    Severity = VulnerabilitySeverity.Medium,
                    Description = "Missing Content-Security-Policy header",
                    Evidence = "HTML response without CSP header increases XSS risk",
                    StatusCode = statusCode
                });
            }
        }
    }

    private async Task ScanForCsrfVulnerabilitiesAsync(string endpoint)
    {
        try
        {
            // Check for CSRF protection on state-changing operations
            var postResponse = await _httpClient.PostAsync(endpoint, new StringContent("{}", Encoding.UTF8, "application/json"));
            
            if (postResponse.IsSuccessStatusCode)
            {
                // Check if request succeeded without CSRF token
                var hasAntiForgeryCookie = _httpClient.DefaultRequestHeaders.Contains("X-CSRF-TOKEN") ||
                                         _httpClient.DefaultRequestHeaders.Contains("X-XSRF-TOKEN");

                if (!hasAntiForgeryCookie)
                {
                    _vulnerabilities.Add(new SecurityVulnerability
                    {
                        Type = VulnerabilityType.CrossSiteRequestForgery,
                        Severity = VulnerabilitySeverity.Medium,
                        Description = "Potential CSRF vulnerability - state-changing operation without CSRF protection",
                        Evidence = "POST request succeeded without CSRF token",
                        StatusCode = (int)postResponse.StatusCode
                    });
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error testing CSRF vulnerability: {ex.Message}");
        }
    }

    private async Task ScanForSecurityHeadersAsync(string endpoint)
    {
        try
        {
            var response = await _httpClient.GetAsync(endpoint);
            var statusCode = (int)response.StatusCode;

            var requiredHeaders = new Dictionary<string, VulnerabilitySeverity>
            {
                { "X-Content-Type-Options", VulnerabilitySeverity.Medium },
                { "X-Frame-Options", VulnerabilitySeverity.Medium },
                { "X-XSS-Protection", VulnerabilitySeverity.Low },
                { "Strict-Transport-Security", VulnerabilitySeverity.High },
                { "Content-Security-Policy", VulnerabilitySeverity.Medium },
                { "Referrer-Policy", VulnerabilitySeverity.Low }
            };

            foreach (var header in requiredHeaders)
            {
                if (!response.Headers.Contains(header.Key) && 
                    !response.Content.Headers.Contains(header.Key))
                {
                    _vulnerabilities.Add(new SecurityVulnerability
                    {
                        Type = VulnerabilityType.MissingSecurityHeaders,
                        Severity = header.Value,
                        Description = $"Missing security header: {header.Key}",
                        Evidence = $"Response does not include {header.Key} header",
                        StatusCode = statusCode
                    });
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error testing security headers: {ex.Message}");
        }
    }

    private async Task ScanForInformationDisclosureAsync(string endpoint)
    {
        try
        {
            var response = await _httpClient.GetAsync(endpoint);
            var content = await response.Content.ReadAsStringAsync();
            var statusCode = (int)response.StatusCode;

            // Check for sensitive information in response
            var sensitivePatterns = new[]
            {
                @"password\s*[:=]\s*['""][^'""]+['""]",
                @"api[_-]?key\s*[:=]\s*['""][^'""]+['""]",
                @"secret\s*[:=]\s*['""][^'""]+['""]",
                @"token\s*[:=]\s*['""][^'""]+['""]",
                @"connection[_-]?string\s*[:=]\s*['""][^'""]+['""]",
                @"database\s*[:=]\s*['""][^'""]+['""]",
                @"server\s*[:=]\s*['""][^'""]+['""]",
                @"System\.Exception",
                @"StackTrace",
                @"at\s+[\w\.]+\(",
                @"Exception\s+Details"
            };

            foreach (var pattern in sensitivePatterns)
            {
                if (Regex.IsMatch(content, pattern, RegexOptions.IgnoreCase))
                {
                    _vulnerabilities.Add(new SecurityVulnerability
                    {
                        Type = VulnerabilityType.InformationDisclosure,
                        Severity = VulnerabilitySeverity.Medium,
                        Description = "Potential information disclosure",
                        Evidence = $"Sensitive pattern found: {pattern}",
                        StatusCode = statusCode
                    });
                }
            }

            // Check server header for version information
            if (response.Headers.Server != null)
            {
                var serverHeader = string.Join(", ", response.Headers.Server.Select(s => s.Product?.ToString()));
                if (!string.IsNullOrEmpty(serverHeader))
                {
                    _vulnerabilities.Add(new SecurityVulnerability
                    {
                        Type = VulnerabilityType.InformationDisclosure,
                        Severity = VulnerabilitySeverity.Low,
                        Description = "Server version information disclosed",
                        Evidence = $"Server header: {serverHeader}",
                        StatusCode = statusCode
                    });
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error testing information disclosure: {ex.Message}");
        }
    }
}

public class SecurityScanResult
{
    public string Endpoint { get; set; } = string.Empty;
    public List<SecurityVulnerability> Vulnerabilities { get; set; } = new();
    public DateTime ScanDate { get; set; }
}

public class SecurityVulnerability
{
    public VulnerabilityType Type { get; set; }
    public VulnerabilitySeverity Severity { get; set; }
    public string Description { get; set; } = string.Empty;
    public string Payload { get; set; } = string.Empty;
    public string Evidence { get; set; } = string.Empty;
    public int StatusCode { get; set; }
}

public enum VulnerabilityType
{
    SqlInjection,
    CrossSiteScripting,
    CrossSiteRequestForgery,
    MissingSecurityHeaders,
    InformationDisclosure,
    AuthenticationBypass,
    AuthorizationEscalation
}

public enum VulnerabilitySeverity
{
    Low,
    Medium,
    High,
    Critical
}